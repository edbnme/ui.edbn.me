{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-controllable-state",
  "type": "registry:hook",
  "title": "useControllableState",
  "description": "Hook for handling controlled/uncontrolled state pattern in components.",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "hooks/use-controllable-state.ts",
      "content": "\"use client\";\r\n\r\nimport {\r\n  useState,\r\n  useCallback,\r\n  useRef,\r\n  useEffect,\r\n  type Dispatch,\r\n  type SetStateAction,\r\n} from \"react\";\r\n\r\n/**\r\n * Configuration for useControllableState hook\r\n */\r\nexport interface UseControllableStateParams<T> {\r\n  /**\r\n   * The controlled value. If provided, the component is controlled.\r\n   */\r\n  value?: T;\r\n  /**\r\n   * The default value for uncontrolled mode.\r\n   */\r\n  defaultValue?: T | (() => T);\r\n  /**\r\n   * Callback fired when the value changes.\r\n   */\r\n  onChange?: (value: T) => void;\r\n}\r\n\r\n/**\r\n * Hook for creating state that can be either controlled or uncontrolled.\r\n *\r\n * This pattern allows components to work in both controlled and uncontrolled modes,\r\n * giving consumers flexibility in how they use the component.\r\n *\r\n * @param params - Configuration parameters\r\n * @returns A tuple of [value, setValue] similar to useState\r\n *\r\n * @example\r\n * ```tsx\r\n * // Uncontrolled usage\r\n * function MyComponent({ defaultOpen, onOpenChange }) {\r\n *   const [isOpen, setIsOpen] = useControllableState({\r\n *     defaultValue: defaultOpen ?? false,\r\n *     onChange: onOpenChange,\r\n *   });\r\n *\r\n *   return <div>{isOpen ? 'Open' : 'Closed'}</div>;\r\n * }\r\n *\r\n * // Controlled usage\r\n * function MyComponent({ open, onOpenChange }) {\r\n *   const [isOpen, setIsOpen] = useControllableState({\r\n *     value: open,\r\n *     onChange: onOpenChange,\r\n *   });\r\n *\r\n *   return <div>{isOpen ? 'Open' : 'Closed'}</div>;\r\n * }\r\n * ```\r\n */\r\nexport function useControllableState<T>({\r\n  value: controlledValue,\r\n  defaultValue,\r\n  onChange,\r\n}: UseControllableStateParams<T>): [T, Dispatch<SetStateAction<T>>] {\r\n  // Determine if component is controlled\r\n  const isControlled = controlledValue !== undefined;\r\n  const isControlledRef = useRef(isControlled);\r\n\r\n  // Warn about switching between controlled and uncontrolled\r\n  useEffect(() => {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      if (isControlledRef.current !== isControlled) {\r\n        console.warn(\r\n          \"A component is changing from \" +\r\n            (isControlledRef.current ? \"controlled\" : \"uncontrolled\") +\r\n            \" to \" +\r\n            (isControlled ? \"controlled\" : \"uncontrolled\") +\r\n            \". This is likely caused by the value changing from a defined to undefined, \" +\r\n            \"which should not happen. Decide between using a controlled or uncontrolled \" +\r\n            \"component for the lifetime of the component.\",\r\n        );\r\n      }\r\n    }\r\n  }, [isControlled]);\r\n\r\n  // Internal state for uncontrolled mode\r\n  const [uncontrolledValue, setUncontrolledValue] = useState<T>(() => {\r\n    if (typeof defaultValue === \"function\") {\r\n      return (defaultValue as () => T)();\r\n    }\r\n    return defaultValue as T;\r\n  });\r\n\r\n  // The value to use (controlled or uncontrolled)\r\n  const value = isControlled ? controlledValue : uncontrolledValue;\r\n\r\n  // Stable reference to onChange callback\r\n  const onChangeRef = useRef(onChange);\r\n  useEffect(() => {\r\n    onChangeRef.current = onChange;\r\n  }, [onChange]);\r\n\r\n  // Setter function that handles both modes\r\n  const setValue = useCallback(\r\n    (nextValue: SetStateAction<T>) => {\r\n      const resolvedValue =\r\n        typeof nextValue === \"function\"\r\n          ? (nextValue as (prev: T) => T)(value)\r\n          : nextValue;\r\n\r\n      // In uncontrolled mode, update internal state\r\n      if (!isControlled) {\r\n        setUncontrolledValue(resolvedValue);\r\n      }\r\n\r\n      // Always call onChange if provided\r\n      onChangeRef.current?.(resolvedValue);\r\n    },\r\n    [isControlled, value],\r\n  );\r\n\r\n  return [value, setValue];\r\n}\r\n\r\n/**\r\n * Simpler version for boolean state (common for open/close patterns)\r\n */\r\nexport interface UseControllableBooleanParams {\r\n  value?: boolean;\r\n  defaultValue?: boolean;\r\n  onChange?: (value: boolean) => void;\r\n}\r\n\r\n/**\r\n * Specialized hook for boolean controllable state\r\n *\r\n * @param params - Configuration parameters\r\n * @returns Tuple with value, setValue, and convenience methods\r\n *\r\n * @example\r\n * ```tsx\r\n * const [isOpen, setIsOpen, { open, close, toggle }] = useControllableBoolean({\r\n *   defaultValue: false,\r\n *   onChange: onOpenChange,\r\n * });\r\n * ```\r\n */\r\nexport function useControllableBoolean({\r\n  value,\r\n  defaultValue = false,\r\n  onChange,\r\n}: UseControllableBooleanParams): [\r\n  boolean,\r\n  Dispatch<SetStateAction<boolean>>,\r\n  { open: () => void; close: () => void; toggle: () => void },\r\n] {\r\n  const [isOpen, setIsOpen] = useControllableState({\r\n    value,\r\n    defaultValue,\r\n    onChange,\r\n  });\r\n\r\n  const open = useCallback(() => setIsOpen(true), [setIsOpen]);\r\n  const close = useCallback(() => setIsOpen(false), [setIsOpen]);\r\n  const toggle = useCallback(() => setIsOpen((prev) => !prev), [setIsOpen]);\r\n\r\n  return [isOpen, setIsOpen, { open, close, toggle }];\r\n}\r\n\r\nexport default useControllableState;\r\n",
      "type": "registry:hook"
    }
  ]
}