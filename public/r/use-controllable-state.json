{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-controllable-state",
  "type": "registry:hook",
  "title": "useControllableState",
  "description": "Hook for handling controlled/uncontrolled state pattern in components.",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "hooks/use-controllable-state.ts",
      "content": "\"use client\";\n\nimport {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  type Dispatch,\n  type SetStateAction,\n} from \"react\";\n\n/**\n * Configuration for useControllableState hook\n */\nexport interface UseControllableStateParams<T> {\n  /**\n   * The controlled value. If provided, the component is controlled.\n   */\n  value?: T;\n  /**\n   * The default value for uncontrolled mode.\n   */\n  defaultValue?: T | (() => T);\n  /**\n   * Callback fired when the value changes.\n   */\n  onChange?: (value: T) => void;\n}\n\n/**\n * Hook for creating state that can be either controlled or uncontrolled.\n *\n * This pattern allows components to work in both controlled and uncontrolled modes,\n * giving consumers flexibility in how they use the component.\n *\n * @param params - Configuration parameters\n * @returns A tuple of [value, setValue] similar to useState\n *\n * @example\n * ```tsx\n * // Uncontrolled usage\n * function MyComponent({ defaultOpen, onOpenChange }) {\n *   const [isOpen, setIsOpen] = useControllableState({\n *     defaultValue: defaultOpen ?? false,\n *     onChange: onOpenChange,\n *   });\n *\n *   return <div>{isOpen ? 'Open' : 'Closed'}</div>;\n * }\n *\n * // Controlled usage\n * function MyComponent({ open, onOpenChange }) {\n *   const [isOpen, setIsOpen] = useControllableState({\n *     value: open,\n *     onChange: onOpenChange,\n *   });\n *\n *   return <div>{isOpen ? 'Open' : 'Closed'}</div>;\n * }\n * ```\n */\nexport function useControllableState<T>({\n  value: controlledValue,\n  defaultValue,\n  onChange,\n}: UseControllableStateParams<T>): [T, Dispatch<SetStateAction<T>>] {\n  // Determine if component is controlled\n  const isControlled = controlledValue !== undefined;\n  const isControlledRef = useRef(isControlled);\n\n  // Warn about switching between controlled and uncontrolled\n  useEffect(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (isControlledRef.current !== isControlled) {\n        console.warn(\n          \"A component is changing from \" +\n            (isControlledRef.current ? \"controlled\" : \"uncontrolled\") +\n            \" to \" +\n            (isControlled ? \"controlled\" : \"uncontrolled\") +\n            \". This is likely caused by the value changing from a defined to undefined, \" +\n            \"which should not happen. Decide between using a controlled or uncontrolled \" +\n            \"component for the lifetime of the component.\",\n        );\n      }\n    }\n  }, [isControlled]);\n\n  // Internal state for uncontrolled mode\n  const [uncontrolledValue, setUncontrolledValue] = useState<T>(() => {\n    if (typeof defaultValue === \"function\") {\n      return (defaultValue as () => T)();\n    }\n    return defaultValue as T;\n  });\n\n  // The value to use (controlled or uncontrolled)\n  const value = isControlled ? controlledValue : uncontrolledValue;\n\n  // Stable reference to onChange callback\n  const onChangeRef = useRef(onChange);\n  useEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  // Setter function that handles both modes\n  const setValue = useCallback(\n    (nextValue: SetStateAction<T>) => {\n      const resolvedValue =\n        typeof nextValue === \"function\"\n          ? (nextValue as (prev: T) => T)(value)\n          : nextValue;\n\n      // In uncontrolled mode, update internal state\n      if (!isControlled) {\n        setUncontrolledValue(resolvedValue);\n      }\n\n      // Always call onChange if provided\n      onChangeRef.current?.(resolvedValue);\n    },\n    [isControlled, value],\n  );\n\n  return [value, setValue];\n}\n\n/**\n * Simpler version for boolean state (common for open/close patterns)\n */\nexport interface UseControllableBooleanParams {\n  value?: boolean;\n  defaultValue?: boolean;\n  onChange?: (value: boolean) => void;\n}\n\n/**\n * Specialized hook for boolean controllable state\n *\n * @param params - Configuration parameters\n * @returns Tuple with value, setValue, and convenience methods\n *\n * @example\n * ```tsx\n * const [isOpen, setIsOpen, { open, close, toggle }] = useControllableBoolean({\n *   defaultValue: false,\n *   onChange: onOpenChange,\n * });\n * ```\n */\nexport function useControllableBoolean({\n  value,\n  defaultValue = false,\n  onChange,\n}: UseControllableBooleanParams): [\n  boolean,\n  Dispatch<SetStateAction<boolean>>,\n  { open: () => void; close: () => void; toggle: () => void },\n] {\n  const [isOpen, setIsOpen] = useControllableState({\n    value,\n    defaultValue,\n    onChange,\n  });\n\n  const open = useCallback(() => setIsOpen(true), [setIsOpen]);\n  const close = useCallback(() => setIsOpen(false), [setIsOpen]);\n  const toggle = useCallback(() => setIsOpen((prev) => !prev), [setIsOpen]);\n\n  return [isOpen, setIsOpen, { open, close, toggle }];\n}\n\nexport default useControllableState;\n",
      "type": "registry:hook"
    }
  ]
}